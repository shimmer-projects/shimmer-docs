=== JVM体系结构概述

. 请谈谈你对JVM的理解?java8的虚拟机有什么更新？
. 什么是OOM？什么是StackOverflowError?有哪些方法分析？
. JVM的常用参数调优你知道哪些？
. 内存快照抓取和MAT分析DUMP文件知道吗？
. 谈谈JVM中，对类加载器你的认识？

==== JVM运行位置

JVM是运行在操作系统之上的，他与硬件没有直接的交互
image:../images/jvm组成结构.png[]

image:../images/jvm模型.png[]

image:../images/jvm体系结构.png[]
. Class Loader类加载器 . ExecutionEngine 执行引擎负责解释命令，提交操作系统执行。 . Native Interface 本地接口 . Runtime data area 运行数据区

===== 类装载器ClassLoader

负责加载class文件，class文件在文件开头有特定的文件标示，并且ClassLoader只负责class文件的加载，至于它是否可以运行，则由Execution Engine决定
image:../images/ClassLoader.png[]

[source,base]
----
echo %JAVA_HOME%
echo %PATH%
echo %CLASSPATH%
----

image:../images/类加载器加载方式.png[]

- 虚拟机自带的加载器
* 启动类加载器（Bootstrap）C++
* 扩展类加载器（Extension）Java
* 应用程序类加载器（AppClassLoader）Java
* 也叫系统类加载器，加载当前应用的classpath的所有类

- 用户自定义加载器
* Java.lang.ClassLoader的子类，用户可以定制类的加载方式

- sun.misc.Launcher
* 它是一个java虚拟机的入口应用

===== Native Interface本地接口

本地接口的作用是融合不同的编程语言为 Java 所用，它的初衷是融合 C/C++程序，Java 诞生的时候是 C/C++横行的时候，要想立足，必须有调用 C/C++程序，于是就在内存中专门开辟了一块区域处理标记为native的代码，它的具体做法是 Native Method Stack中登记 native方法，在Execution Engine 执行时加载native libraies。 目前该方法使用的越来越少了，除非是与硬件有关的应用，比如通过Java程序驱动打印机或者Java系统管理生产设备，在企业级应用中已经比较少见。因为现在的异构领域间的通信很发达，比如可以使用 Socket通信，也可以使用Web Service等等，不多做介绍。

===== Native Method Stack

它的具体做法是Native Method Stack中登记native方法，在Execution Engine 执行时加载本地方法库。

===== PC寄存器

每个线程都有一个程序计数器，是线程私有的,就是一个指针，指向方法区中的方法字节码（用来存储指向下一条指令的地址,也即将要执行的指令代码），由执行引擎读取下一条指令，是一个非常小的内存空间，几乎可以忽略不记。

这块内存区域很小，它是当前线程所执行的字节码的行号指示器，字节码解释器通过改变这个计数器的值来选取下一条需要执行的字节码指令。

如果执行的是一个Native方法，那这个计数器是空的。

===== Method Area 方法区

方法区是被所有线程共享，所有字段和方法字节码，以及一些特殊方法如构造函数，接口代码也在此定义。简单说，所有定义的方法的信息都保存在该区域，此区属于共享区间。 静态变量+常量+类信息(构造方法/接口定义)+运行时常量池存在方法区中 But 实例变量存在堆内存中,和方法区无关

6 Stack 栈是什么 栈也叫栈内存，主管Java程序的运行，是在线程创建时创建，它的生命期是跟随线程的生命期，线程结束栈内存也就释放，对于栈来说不存在垃圾回收问题，只要线程一结束该栈就Over，生命周期和线程一致，是线程私有的。8种基本类型的变量+对象的引用变量+实例方法都是在函数的栈内存中分配。

6.1 栈存储什么?
栈帧中主要保存3 类数据：

本地变量（Local Variables）:输入参数和输出参数以及方法内的变量；

栈操作（Operand Stack）:记录出栈、入栈的操作；

栈帧数据（Frame Data）:包括类文件、方法等等。

6.2 栈运行原理： 栈中的数据都是以栈帧（Stack Frame）的格式存在，栈帧是一个内存区块，是一个数据集，是一个有关方法(Method)和运行期数据的数据集， 当一个方法A被调用时就产生了一个栈帧 F1，并被压入到栈中， A方法又调用了 B方法，于是产生栈帧 F2 也被压入栈， B方法又调用了 C方法，于是产生栈帧 F3 也被压入栈， 。。。。。。 执行完毕后，先弹出F3栈帧，再弹出F2栈帧，再弹出F1栈帧……

遵循“先进后出”/“后进先出”原则。

每个方法执行的同时都会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接、方法出口等信息，每一个方法从调用直至执行完毕的过程，就对应着一个栈帧在虚拟机中入栈到出栈的过程。栈的大小和具体JVM的实现有关，通常在256K~756K之间。

image:../images/java-stack.png[]
图示在一个栈中有两个栈帧：

- 栈帧 2是最先被调用的方法，先入栈，
- 然后方法 2 又调用了方法1，栈帧 1处于栈顶的位置，
- 栈帧 2 处于栈底，执行完毕后，依次弹出栈帧 1和栈帧 2，
- 线程结束，栈释放。

每执行一个方法都会产生一个栈帧，保存到栈(后进先出)的顶部，顶部栈就是当前的方法，该方法执行完毕 后会自动将此栈帧出栈。

Exception in thread "main" java.lang.StackOverflowError
image:../images/stackoverflow.png[]

栈+堆+方法区的交互关系
image:../images/relation-stack-method-heap.png[]

. HotSpot是使用指针的方式来访问对象：
. Java堆中会存放访问类元数据的地址，
. reference存储的就直接是对象的地址

三种JVM

. Sun公司的HotSpot
. BEA公司的JRockit
. IBM公司的J9 VM

栈管运行，堆管存储

天上飞的理念，地上落地实现

JVM 默认只能使用物理内存的1/4

=== JVM堆体系结构概述

7 Heap 堆 一个JVM实例只存在一个堆内存，堆内存的大小是可以调节的。类加载器读取了类文件后，需要把类、方法、常变量放到堆内存中，保存所有引用类型的真实信息，以方便执行器执行，堆内存分为三部分

Heap堆(Java7之前) 一个JVM实例只存在一个堆内存，堆内存的大小是可以调节的。类加载器读取了类文件后，需要把类、方法、常变量放到堆内存中，保存所有引用类型的真实信息，以方便执行器执行。 堆内存逻辑上分为三部分：新生+养老+永久

image:../images/heap.png[]

- Young Generation Space 新生区 Young/New
- Tenure generation space 养老区 Old/ Tenure
- Permanent Space 永久区 Perm

新生区 新生区是类的诞生、成长、消亡的区域，一个类在这里产生，应用，最后被垃圾回收器收集，结束生命。 新生区又分为两部分： 伊甸区（Eden space）和幸存者区（Survivor pace） ，所有的类都是在伊甸区被new出来的。 幸存区有两个： 0区（Survivor 0 space）和1区（Survivor 1 space）。 当伊甸园的空间用完时，程序又需要创建对象，JVM的垃圾回收器将对伊甸园区进行垃圾回收(Minor GC)， 将伊甸园区中的不再被其他对象所引用的对象进行销毁。然后将伊甸园中的剩余对象移动到幸存 0区。 若幸存 0区也满了，再对该区进行垃圾回收，然后移动到 1 区。那如果1 区也满了呢？再移动到养老区。 若养老区也满了，那么这个时候将产生MajorGC（FullGC），进行养老区的内存清理。 若养老区执行了Full GC之后发现依然无法进行对象的保存，就会产生OOM异常“OutOfMemoryError”。

如果出现java.lang.OutOfMemoryError: Java heap space异常，说明Java虚拟机的堆内存不够。原因有二： （1）Java虚拟机的堆内存设置不够，可以通过参数-Xms、-Xmx来调整。 （2）代码中创建了大量大对象，并且长时间不能被垃圾收集器收集（存在被引用）。

image:../images/HotSpot内容管理.png[]
image:../images/new-young.png[]
image:../images/old-space.png[]

永久区 永久存储区是一个常驻内存区域，用于存放JDK自身所携带的 Class,Interface 的元数据，也就是说它存储的是运行环境必须的类信息，被装载进此区域的数据是不会被垃圾回收器回收掉的，关闭 JVM 才会释放此区域所占用的内存。

如果出现java.lang.OutOfMemoryError: PermGen space，说明是Java虚拟机对永久代Perm内存设置不够。一般出现这种情况，都是程序启动需要加载大量的第三方jar包。例如：在一个Tomcat下部署了太多的应用。或者大量动态反射生成的类不断被加载，最终导致Perm区被占满。

- JDK1.6及之前： 有永久代，常量池1。6在方法区
- JDK1.7: 有永久代，但已经逐步"去永久代"，常量池1.7在堆
- JDK1.8: 无永久代，常量池1.8在元空间

熟悉三区结构后方可学习-JVM垃圾收集

实际而言，方法区（Method Area）和堆一样，是各个线程共享的内存区域，它用于存储虚拟机加载的：类信息+普通常量+静态常量+编译器编译后的代码等等，虽然JVM规范将方法区描述为堆的一个逻辑部分，但它却还有一个别名叫做Non-Heap(非堆)，目的就是要和堆分开。

对于HotSpot虚拟机，很多开发者习惯将方法区称之为“永久代(Parmanent Gen)” ，但严格本质上说两者不同，或者说使用永久代来实现方法区而已，永久代是方法区(相当于是一个接口interface)的一个实现，jdk1.7的版本中，已经将原本放在永久代的字符串常量池移走。

image:../images/space-model.png[]

=== 堆参数调优入门

JVM垃圾收集(Java Garbage Collection )

上集，本次均以JDK1.8+HotSpot为例

=== 总结

=== 初识JVM

==== JVM的概念

- JVM是Java Virtual Machine的简称。意为Java虚拟机
- 虚拟机 指通过软件模拟的具有完整硬件系统功能的、运行在一个完全隔离环境中的完整计算机系统
- 有哪些虚拟机
* VMWare
* Visual Box
* JVM
- VMWare或者Visual Box都是使用软件模拟物理CPU的指令集
- JVM使用软件模拟Java 字节码的指令集

==== JVM发展历史

- 1996年 SUN JDK 1.0 Classic VM
* 纯解释运行，使用外挂进行JIT
- 1997年 JDK1.1 发布
* AWT、内部类、JDBC、RMI、反射
- 1998年 JDK1.2 Solaris Exact VM
* JIT 解释器混合
* Accurate Memory Management 精确内存管理，数据类型敏感（JDK1.2开始 称为Java2 J2SE J2EE J2ME 的出现 加入Swing Collections ）
* 提升的GC性能
- 2000年 JDK 1.3 Hotspot 作为默认虚拟机发布（加入JavaSound ）
- 2002年 JDK 1.4 Classic VM退出历史舞台（Assert 正则表达式 NIO IPV6 日志API 加密类库 ）
- 2004年发布 JDK1.5 即 JDK5 、J2SE 5 、Java 5
* 泛型
* 注解
* 装箱
* 枚举
* 可变长的参数
* Foreach循环
- JDK1.6 JDK6
* 脚本语言支持
* JDBC 4.0
* Java编译器 API
- 2011年 JDK7发布
* 延误项目推出到JDK8
* G1
* 动态语言增强
* 64位系统中的压缩指针
* NIO 2.0
- 2014年 JDK8发布
* Lambda表达式
* 语法增强 Java类型注解
- 2016年JDK9
* 模块化
- 使用最为广泛的JVM为HotSpot
* HotSpot 为Longview Technologies开发 被SUN收购
- 2006年 Java开源 并建立OpenJDK
* HotSpot 成为Sun JDK和OpenJDK中所带的虚拟机
- 2008 年 Oracle收购BEA
* 得到JRockit VM
- 2010年Oracle 收购 Sun
* 得到Hotspot
- Oracle宣布在JDK8时整合JRockit和Hotspot，优势互补
* 在Hotspot基础上，移植JRockit优秀特性

==== JVM种类

- KVM
* SUN发布
* IOS Android前，广泛用于手机系统
- CDC/CLDC HotSpot
* 手机、电子书、PDA等设备上建立统一的Java编程接口
* J2ME的重要组成部分
- JRockit
* BEA
- IBM J9 VM
* IBM内部
- Apache Harmony
* 兼容于JDK 1.5和JDK 1.6的Java程序运行平台
* 与Oracle关系恶劣 退出JCP ，Java社区的分裂
* OpenJDK出现后，受到挑战 2011年 退役
* 没有大规模商用经历
* 对Android的发展有积极作用

==== Java语言规范

- Java语言规范
* 语法
* 变量
* 类型
* 文法
- JVM规范
* Class文件类型
* 运行时数据
* 帧栈
* 虚拟机的启动
* 虚拟机的指令集

==== JVM规范

- Java语言规范定义了什么是Java语言
- Java语言和JVM相对独立
* Groovy
* Clojure
* Scala
- JVM主要定义二进制class文件和JVM指令集等
- Class 文件格式
- 数字的内部表示和存储
* Byte -128 to 127 (-27 to 27 - 1)
- returnAddress 数据类型定义
* 指向操作码的指针。不对应Java数据类型，不能在运行时修改。Finally实现需要
- 定义PC
- 堆
- 栈
- 方法区
- VM指令集
- JVM需要对Java Library 提供以下支持：
* 反射 java.lang.reflect
* ClassLoader
* 初始化class和interface
* 安全相关 java.security
* 多线程
* 弱引用
- JVM的编译

=== JVM运行机制

==== JVM启动流程

image:../images/JVM启动流程.png[]

==== JVM基本结构

image:../images/JVM基本结构.png[]

PC寄存器

- 每个线程拥有一个PC寄存器
- 在线程创建时 创建
- 指向下一条指令的地址
- 执行本地方法时，PC的值为undefined

方法区

- 保存装载的类信息
* 类型的常量池 (JDK6时，String等常量信息置于方法区，JDK7时，已经移动到了堆)
* 字段，方法信息
* 方法字节码
- 通常和永久区(Perm)关联在一起

Java堆

- 和程序开发密切相关
- 应用系统对象都保存在Java堆中
- 所有线程共享Java堆
- 对分代GC来说，堆也是分代的
- GC的主要工作区间

Java栈

- 线程私有
- 栈由一系列帧组成（因此Java栈也叫做帧栈）
- 帧保存一个方法的局部变量、操作数栈、常量池指针
- 每一次方法调用创建一个帧，并压栈

==== 内存模型

==== 编译和解释运行的概念

JVM垃圾回收器
image:../images/garbage-collectors.png[]

JVM GC回收策略

- Copying 复制回收算法
image:../images/copying.png[]
- Mark-Sweep 标记清除算法
image:../images/mark-sweep.png[]
- Mark-Compact 标记压缩算法
image:../images/Mark-Compact.png[]

JVM检测垃圾算法

- 引用计数算法
- 根可达算法
image:../images/root-searching.png[]

=== JVM分代模型
image:../images/分代模型.png[]

s0-s1之间复制年龄超过限制时，进入老年代，通过参数：-XX：MaxTenuringThreshold配置
image:../images/gc1.png[]

=== 常用JVM配置参数

==== Trace跟踪参数

- -verbose:gc
- -XX:+printGC 可以打印GC的简要信息

----
[GC 4790K->374K(15872K), 0.0001606 secs]
[GC 4790K->374K(15872K), 0.0001474 secs]
[GC 4790K->374K(15872K), 0.0001563 secs]
[GC 4790K->374K(15872K), 0.0001682 secs]
----

- -XX:+PrintGCDetails 打印GC详细信息
- -XX:+PrintGCTimeStamps 打印CG发生的时间戳 例

----
[GC[DefNew: 4416K->0K(4928K), 0.0001897 secs] 4790K->374K(15872K), 0.0002232 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]
----

- -XX:+PrintGCDetails的输出

----
Heap
def new generation   total 13824K, used 11223K [0x27e80000, 0x28d80000, 0x28d80000)
eden space 12288K,  91% used [0x27e80000, 0x28975f20, 0x28a80000)
from space 1536K,   0% used [0x28a80000, 0x28a80000, 0x28c00000)
to   space 1536K,   0% used [0x28c00000, 0x28c00000, 0x28d80000)
tenured generation   total 5120K, used 0K [0x28d80000, 0x29280000, 0x34680000)
the space 5120K,   0% used [0x28d80000, 0x28d80000, 0x28d80200, 0x29280000)
compacting perm gen  total 12288K, used 142K [0x34680000, 0x35280000, 0x38680000)
the space 12288K,   1% used [0x34680000, 0x346a3a90, 0x346a3c00, 0x35280000)
ro space 10240K,  44% used [0x38680000, 0x38af73f0, 0x38af7400, 0x39080000)
rw space 12288K,  52% used [0x39080000, 0x396cdd28, 0x396cde00, 0x39c80000)
----

新生代总内存 + 老年代总内存 = JVM总内存


低边界 当前边界 最高边界

[0x27e80000, 0x28d80000, 0x28d80000)

(0x28d80000-0x27e80000)/1024/1024=15M

- -Xloggc:log/gc.log 指定GC log的位置，以文件输出 ,帮助开发人员分析问题
- -XX:+PrintHeapAtGC 每次一次GC后，都打印堆信息

----
{Heap before GC invocations=0 (full 0):
 def new generation   total 3072K, used 2752K [0x33c80000, 0x33fd0000, 0x33fd0000)
  eden space 2752K, 100% used [0x33c80000, 0x33f30000, 0x33f30000)
  from space 320K,   0% used [0x33f30000, 0x33f30000, 0x33f80000)
  to   space 320K,   0% used [0x33f80000, 0x33f80000, 0x33fd0000)
 tenured generation   total 6848K, used 0K [0x33fd0000, 0x34680000, 0x34680000)
   the space 6848K,   0% used [0x33fd0000, 0x33fd0000, 0x33fd0200, 0x34680000)
 compacting perm gen  total 12288K, used 143K [0x34680000, 0x35280000, 0x38680000)
   the space 12288K,   1% used [0x34680000, 0x346a3c58, 0x346a3e00, 0x35280000)
    ro space 10240K,  44% used [0x38680000, 0x38af73f0, 0x38af7400, 0x39080000)
    rw space 12288K,  52% used [0x39080000, 0x396cdd28, 0x396cde00, 0x39c80000)
[GC[DefNew: 2752K->320K(3072K), 0.0014296 secs] 2752K->377K(9920K), 0.0014604 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]
Heap after GC invocations=1 (full 0):
 def new generation   total 3072K, used 320K [0x33c80000, 0x33fd0000, 0x33fd0000)
  eden space 2752K,   0% used [0x33c80000, 0x33c80000, 0x33f30000)
  from space 320K, 100% used [0x33f80000, 0x33fd0000, 0x33fd0000)
  to   space 320K,   0% used [0x33f30000, 0x33f30000, 0x33f80000)
 tenured generation   total 6848K, used 57K [0x33fd0000, 0x34680000, 0x34680000)
   the space 6848K,   0% used [0x33fd0000, 0x33fde458, 0x33fde600, 0x34680000)
 compacting perm gen  total 12288K, used 143K [0x34680000, 0x35280000, 0x38680000)
   the space 12288K,   1% used [0x34680000, 0x346a3c58, 0x346a3e00, 0x35280000)
    ro space 10240K,  44% used [0x38680000, 0x38af73f0, 0x38af7400, 0x39080000)
    rw space 12288K,  52% used [0x39080000, 0x396cdd28, 0x396cde00, 0x39c80000)
}
----

- -XX:+TraceClassLoading 监控类的加载

----
[Loaded java.lang.Object from shared objects file]
[Loaded java.io.Serializable from shared objects file]
[Loaded java.lang.Comparable from shared objects file]
[Loaded java.lang.CharSequence from shared objects file]
[Loaded java.lang.String from shared objects file]
[Loaded java.lang.reflect.GenericDeclaration from shared objects file]
[Loaded java.lang.reflect.Type from shared objects file]
----

- -XX:+PrintClassHistogram
* 按下Ctrl+Break后，打印类的信息：
* 分别显示：序号、实例数量、总大小、类型

----
num     #instances       #bytes  class name
----------------------------------------------
1:        890617      470266000  [B
2:        890643       21375432  java.util.HashMap$Node
3:        890608       14249728  java.lang.Long
4:            13        8389712  [Ljava.util.HashMap$Node;
5:          2062         371680  [C
6:           463          41904  java.lang.Class
----

==== 堆的分配参数

- -Xmx –Xms 指定最大堆和最小堆

-Xmx20m -Xms5m 运行代码：

[source,java]
----
public class Test {
    public static void main(String[] args){
      System.out.print("Xmx=");
      System.out.println(Runtime.getRuntime().maxMemory()/1024.0/1024+"M");

      System.out.print("free mem=");
      System.out.println(Runtime.getRuntime().freeMemory()/1024.0/1024+"M");

      System.out.print("total mem=");
      System.out.println(Runtime.getRuntime().totalMemory()/1024.0/1024+"M");
    }
}

----

----
Xmx=19.375M
free mem=4.342750549316406M
total mem=4.875M
----

-Xmx20m -Xms5m 运行代码

[source,java]
----
public class Test {
  public static void main(String[] args){
    byte[] b=new byte[1 * 1024 * 1024];
    System.out.println("分配了1M空间给数组");

    System.out.print("Xmx=");
    System.out.println(Runtime.getRuntime().maxMemory()/1024.0/1024+"M");

    System.out.print("free mem=");
    System.out.println(Runtime.getRuntime().freeMemory()/1024.0/1024+"M");

    System.out.print("total mem=");
    System.out.println(Runtime.getRuntime().totalMemory()/1024.0/1024+"M");

  }
}
----

----
分配了1M空间给数组
Xmx=19.375M
free mem=3.4791183471679688M
total mem=4.875M
----

Java会尽可能维持在最小堆

-Xmx20m -Xms5m 运行代码

[source,java]
----
public class Test {
  public static void main(String[] args){
    byte[] b=new byte[4 * 1024 * 1024];
    System.out.println("分配了1M空间给数组");

    System.out.print("Xmx=");
    System.out.println(Runtime.getRuntime().maxMemory()/1024.0/1024+"M");

    System.out.print("free mem=");
    System.out.println(Runtime.getRuntime().freeMemory()/1024.0/1024+"M");

    System.out.print("total mem=");
    System.out.println(Runtime.getRuntime().totalMemory()/1024.0/1024+"M");

  }
}
----

----
分配了4M空间给数组
Xmx=19.375M
free mem=3.5899810791015625M
total mem=9.00390625M
----

总内存变大了

-Xmx20m -Xms5m 运行代码

[source,java]
----
public class Test {
  public static void main(String[] args){
    System.gc();
    System.out.println("回收内存");

    System.out.print("Xmx=");
    System.out.println(Runtime.getRuntime().maxMemory()/1024.0/1024+"M");

    System.out.print("free mem=");
    System.out.println(Runtime.getRuntime().freeMemory()/1024.0/1024+"M");

    System.out.print("total mem=");
    System.out.println(Runtime.getRuntime().totalMemory()/1024.0/1024+"M");

  }
}
----

----
回收内存
Xmx=19.375M
free mem=6.354591369628906M
total mem=10.75390625M
----

空闲内存增多

==== 栈的分配参数

- -Xmn
* 设置新生代大小
- -XX:NewRatio
* 新生代（eden+2*s）和老年代（不包含永久区）的比值
* 4 表示 新生代:老年代=1:4，即年轻代占堆的1/5
- -XX:SurvivorRatio
* 设置两个Survivor区和eden的比
* 8 表示 两个Survivor:eden = 2:8，即一个Survivor占年轻代的1/10

[source,java]
----
public class Test {
  public static void main(String[] args) {
   byte[] b = null;
   for(int i = 0; i < 10; i++)
       b = new byte[1 * 1024 * 1024];
  }
}
----
-Xmx20m -Xms20m -Xmn1m  -XX:+PrintGCDetails
image:../images/Picture1.png[]

. 没有触发GC
. 全部分配在老年代

-Xmx20m -Xms20m -Xmn15m  -XX:+PrintGCDetails
image:../images/Picture2.png[]

. 没有触发GC
. 全部分配在eden
. 老年代没有使用

-Xmx20m -Xms20m –Xmn7m  -XX:+PrintGCDetails
image:../images/Picture3.png[]

. 进行了2次新生代GC
. s0 s1 太小需要老年代担保

-Xmx20m -Xms20m -Xmn7m   -XX:SurvivorRatio=2 -XX:+PrintGCDetails
image:../images/Picture4.png[]

. 进行了3次新生代GC
. s0 s1 增大

-Xmx20m -Xms20m -XX:NewRatio=1 -XX:SurvivorRatio=2 -XX:+PrintGCDetails
image:../images/Picture5.png[]

-Xmx20m -Xms20m -XX:NewRatio=1 -XX:SurvivorRatio=3 -XX:+PrintGCDetails
image:../images/Picture6.png[]


- -XX:+HeapDumpOnOutOfMemoryError
* OOM时导出堆到文件
- -XX:+HeapDumpPath
* 导出OOM的路径
- -Xmx20m -Xms5m -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=d:/a.dump
[source, java]
----
public class DumpOOM {
  public static void main(String[] args){
    Vector v=new Vector();
    for(int i=0;i<25;i++) {
      v.add(new byte[1*1024*1024]);
    }
  }
}
----

- -XX:OnOutOfMemoryError
* 在OOM时，执行一个脚本
* "-XX:OnOutOfMemoryError=D:/tools/jdk1.7_40/bin/printstack.bat %p“ （D:/tools/jdk1.7_40/bin/jstack -F %1 > D:/a.txt ）
* 当程序OOM时，在D:/a.txt中将会生成线程的dump
* 可以在OOM时，发送邮件，甚至是重启程序

根据实际事情调整新生代和幸存代的大小
官方推荐新生代占堆的3/8
幸存代占新生代的1/10
在OOM时，记得Dump出堆，确保可以排查现场问题

永久区分配参数

- -XX:PermSize  -XX:MaxPermSize
* 设置永久区的初始空间和最大空间
* 他们表示，一个系统可以容纳多少个类型

使用CGLIB等库的时候，可能会产生大量的类，这些类，有可能撑爆永久区导致OOM
[source,java]
----
public class Test {
  public static void main(String[] args){
    for(int i=0;i<100000;i++){
      CglibBean bean = new CglibBean("geym.jvm.ch3.perm.bean"+i, new HashMap()); // 不断产生新的类
    }
  }
}
----
image:../images/Picture7.png[]

- 打开堆的Dump
* 堆空间实际占用非常少
* 但是永久区溢出 一样抛出OOM

image:../images/Picture8.png[]
如果堆空间没有用完也抛出了OOM，有可能是永久区导致的

栈大小分配

- -Xss
* 通常只有几百K
* 决定了函数调用的深度
* 每个线程都有独立的栈空间
* 局部变量、参数 分配在栈上

[source,java]
----
public class TestStackDeep {
	private static int count=0;
	public static void recursion(long a,long b,long c){
		long e=1,f=2,g=3,h=4,i=5,k=6,q=7,x=8,y=9,z=10;
		count++;
		recursion(a,b,c);
	}
	public static void main(String args[]){
		try{
			recursion(0L,0L,0L);
		}catch(Throwable e){
			System.out.println("deep of calling = "+count);
			e.printStackTrace();
		}
	}
}
----
----
递归调用
-Xss128K
deep of calling = 701
java.lang.StackOverflowError

-Xss256K
deep of calling = 1817
java.lang.StackOverflowError
----
去掉局部变量 调用层次可以更深

=== 常用GC配置参数
==== 串行收集器
- 最古老，最稳定
- 效率高
- 可能会产生较长的停顿
- -XX:+UseSerialGC
* 新生代、老年代使用串行回收
* 新生代复制算法
* 老年代标记-压缩

image:../images/串行收集器.png[]

----
0.844: [GC 0.844: [DefNew: 17472K->2176K(19648K), 0.0188339 secs] 17472K->2375K(63360K), 0.0189186 secs] [Times: user=0.01 sys=0.00, real=0.02 secs]

8.259: [Full GC 8.259: [Tenured: 43711K->40302K(43712K), 0.2960477 secs] 63350K->40302K(63360K), [Perm : 17836K->17836K(32768K)], 0.2961554 secs] [Times: user=0.28 sys=0.02, real=0.30 secs]
----


==== 并行收集器
- ParNew
* -XX:+UseParNewGC 新生代并行 + 老年代串行
* Serial收集器新生代的并行版本
* 复制算法
* 多线程，需要多核支持
* -XX:ParallelGCThreads 限制线程数量

image:../images/并行收集器.png[]
----
0.834: [GC 0.834: [ParNew: 13184K->1600K(14784K), 0.0092203 secs] 13184K->1921K(63936K), 0.0093401 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]
----

- Parallel收集器
* 类似ParNew
* 新生代复制算法
* 老年代 标记-压缩
* 更加关注吞吐量
* -XX:+UseParallelGC 使用Parallel收集器 + 老年代串行
* -XX:+UseParallelOldGC 使用Parallel收集器 + 并行老年代

image:../images/并行收集器1.png[]

----
1.500: [Full GC [PSYoungGen: 2682K->0K(19136K)] [ParOldGen: 28035K->30437K(43712K)] 30717K->30437K(62848K) [PSPermGen: 10943K->10928K(32768K)], 0.2902791 secs] [Times: user=1.44 sys=0.03, real=0.30 secs]
----

- -XX:MaxGCPauseMills
* 最大停顿时间，单位毫秒
* GC尽力保证回收时间不超过设定值
- -XX:GCTimeRatio
* 0-100的取值范围
* 垃圾收集时间占总时间的比
* 默认99，即最大允许1%时间做GC
- 这两个参数是矛盾的。因为停顿时间和吞吐量不可能同时调优


==== CMS收集器
- Concurrent Mark Sweep 并发(与用户线程一起执行)标记清除
- 标记-清除算法
- 与标记-压缩相比
- 并发阶段会降低吞吐量
- 老年代收集器（新生代使用ParNew）
- -XX:+UseConcMarkSweepGC

- CMS运行过程比较复杂，着重实现了标记的过程，可分为
* 初始标记
** 根可以直接关联到的对象
** 速度快
* 并发标记（和用户线程一起）
** 主要标记过程，标记全部对象
* 重新标记
** 由于并发标记时，用户线程依然运行，因此在正式清理前，再做修正
* 并发清除（和用户线程一起）
** 基于标记结果，直接清理对象
image:../images/CMS收集器.png[]
----
1.662: [GC [1 CMS-initial-mark: 28122K(49152K)] 29959K(63936K), 0.0046877 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]
1.666: [CMS-concurrent-mark-start]
1.699: [CMS-concurrent-mark: 0.033/0.033 secs] [Times: user=0.25 sys=0.00, real=0.03 secs]
1.699: [CMS-concurrent-preclean-start]
1.700: [CMS-concurrent-preclean: 0.000/0.000 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]
1.700: [GC[YG occupancy: 1837 K (14784 K)]1.700: [Rescan (parallel) , 0.0009330 secs]1.701: [weak refs processing, 0.0000180 secs] [1 CMS-remark: 28122K(49152K)] 29959K(63936K), 0.0010248 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]
1.702: [CMS-concurrent-sweep-start]
1.739: [CMS-concurrent-sweep: 0.035/0.037 secs] [Times: user=0.11 sys=0.02, real=0.05 secs]
1.739: [CMS-concurrent-reset-start]
1.741: [CMS-concurrent-reset: 0.001/0.001 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]
----

- 特点
* 尽可能降低停顿
* 会影响系统整体吞吐量和性能
** 比如，在用户线程运行过程中，分一半CPU去做GC，系统性能在GC阶段，反应速度就下降一半
* 清理不彻底
** 因为在清理阶段，用户线程还在运行，会产生新的垃圾，无法清理
* 因为和用户线程一起运行，不能在空间快满时再清理
** -XX:CMSInitiatingOccupancyFraction设置触发GC的阈值
** 如果不幸内存预留空间不够，就会引起concurrent mode failure

----
33.348: [Full GC 33.348: [CMS33.357: [CMS-concurrent-sweep: 0.035/0.036 secs] [Times: user=0.11 sys=0.03, real=0.03 secs]
 (concurrent mode failure): 47066K->39901K(49152K), 0.3896802 secs] 60771K->39901K(63936K), [CMS Perm : 22529K->22529K(32768K)], 0.3897989 secs] [Times: user=0.39 sys=0.00, real=0.39 secs]
----
使用串行收集器作为后备

- 有关碎片
* 标记-清除和标记-压缩

image:../images/Picture9.png[]

- -XX:+ UseCMSCompactAtFullCollection Full GC后，进行一次整理, 整理过程是独占的，会引起停顿时间变长
- -XX:+CMSFullGCsBeforeCompaction 设置进行几次Full GC后，进行一次碎片整理
- -XX:ParallelCMSThreads 设定CMS的线程数量

GC 参数整理

- -XX:+UseSerialGC：在新生代和老年代使用串行收集器
- -XX:SurvivorRatio：设置eden区大小和survivior区大小的比例
- -XX:NewRatio:新生代和老年代的比
- -XX:+UseParNewGC：在新生代使用并行收集器
- -XX:+UseParallelGC ：新生代使用并行回收收集器
- -XX:+UseParallelOldGC：老年代使用并行回收收集器
- -XX:ParallelGCThreads：设置用于垃圾回收的线程数
- -XX:+UseConcMarkSweepGC：新生代使用并行收集器，老年代使用CMS+串行收集器
- -XX:ParallelCMSThreads：设定CMS的线程数量
- -XX:CMSInitiatingOccupancyFraction：设置CMS收集器在老年代空间被使用多少后触发
- -XX:+UseCMSCompactAtFullCollection：设置CMS收集器在完成垃圾收集后是否要进行一次内存碎片的整理
- -XX:CMSFullGCsBeforeCompaction：设定进行多少次CMS垃圾回收后，进行一次内存压缩
- -XX:+CMSClassUnloadingEnabled：允许对类元数据进行回收
- -XX:CMSInitiatingPermOccupancyFraction：当永久区占用率达到这一百分比时，启动CMS回收
- -XX:UseCMSInitiatingOccupancyOnly：表示只在到达阀值的时候，才进行CMS回收

==== Tomcat实例演示
- 环境
* Tomcat 7
* JSP 网站
* 测试网站吞吐量和延时
- 工具
* JMeter
- 目的
* 让Tomcat有一个不错的吞吐量

image:../images/Snipaste1.png[]
image:../images/Snipaste2.png[]
image:../images/Snipaste3.png[]
image:../images/Snipaste4.png[]
image:../images/Snipaste5.png[]
image:../images/Snipaste6.png[]
image:../images/Snipaste7.png[]
image:../images/Snipaste8.png[]
image:../images/Snipaste9.png[]
image:../images/Snipaste10.png[]


=== 类装载器
### 类加载器

- 类加载器就是加载类的工具
- Java虚拟机中可以安装多个类加载器，系统默认三个主要的类加载器，每个类负责加载特定位置的类：BootStrap，ExtClassLoader，AppClassLoader
- 类加载器也是Java类，因为其他是java类的类加载器本身也要被类加载，显然必须有一个类加载器不是java类。这正是BootStrap。
- Java虚拟机中的所有类装载器采用具有父子关系的树形结构进行组织，在实例化每个类装载器对象时，需要为其指定一个父级类装载器对象或者默认采用系统类装载器为其父级类加载

image:../images/类加载器.png[]

#### 类加载器的委托机制

- 当Java虚拟机要加载一个类时，到底派出哪个类加载器去加载呢？

- 首先当线程的类加载器去加载线程中的第一个类。
- 如果类A中引用了类B，java虚拟机将使用加载类A的类装载器来加载类B。
- 还可以直接调用ClassLoader.loadClass()方法来指定某个类加载器去加载某个类。

- 每个类加载器加载类似，优先委托给其上级类加载器。

- 当所有祖宗类加载器没有加载到类，回到发起者类加载器，还加载不了，则抛ClassNotFoundException,不是再去找发起者类加载器的儿子，因为没有getChild方法，即使有，那么又多个儿子，找哪一个呢？
- 对着类加载器的层次结构图和委托加载原理，解释先前将ClassLoaderTest输出成jre/lib/ext目录下的x.jar包中后，运行结果为ExtClassLoader的原因。

  每个ClassLoader本身只能分别加载特定位置和目录中的类，但他们可以委托其他的类装载器去加载类，这是类加载器的委托模式。类装载器一级级的委托到BootStrap类加载器，当BootStrap无法加载当前所有要加载的类时，然后才一级级回退到子孙类加载器去进行真正的加载。当回退到最初的类加载器是，如果他自己也不能完成类的装载，那就应报告ClassNotFoundException异常。

  有一道面试，能不能自己写个类叫java.lang.System,为了不让我们写System类，类加载采用委托机制，这样可以保证爸爸们优先，也就是总是使用爸爸们能找到的类，这样总是使用java系统提供的System。

#### 编写自己的类加载器

- 知识点

- 自定义的类加载器必须继承ClassLoader
- loadClass方法与findClass方法
- defineClass方法

- 编写步骤

- 编写一个对文件内容进行简单加密的程序
- 编写一个自己的类加载器，可实现对加密过的类进行装载和解密。
- 编写一个程序调用类加载器加载类，在源程序中不能用该类名定义引用变量，因为编译器无法识别这个类，程序中可以除了使用ClassLoader.load方法之外，还可以使用设置线程的上下文类加载器或者系统类加载器，然后再使用Class.forName。

- 实验步骤

- 对不带包名的class文件进行加密，加密结果存放到另外一个目录，例如：java.MyClassLoader.MyTest.class F:\class
- 运行加载类的程序，结果能够被正常加载，但打印出来的类加载器名称为AppClassLoader:java.MyClassLoader MyTest F:\class
- 用加密后的类文件替换ClASSPATH环境下的类文件，在执行上一步操作就出问题了，错误说明是AppClassLoader类在在其装载失败。
- 删除CLASSPATH环境下的类文件名，在执行上一步操作就没问题了。

  **模板方法设计模式**

#### 类加载器的执行顺序

```java
public class ClassLoaderTest {
    public static void main(String[] args) throws ClassNotFoundException, IllegalAccessException, InstantiationException {
        System.out.println(ClassLoaderTest.class.getClassLoader().getClass().getName());
        System.out.println(System.class.getClassLoader());
        //System返回的是null,这两个类存放位置不同。存放位置不同的类有不同的类加载器加载的

        ClassLoader loader = ClassLoaderTest.class.getClassLoader();
        while (loader != null){
            System.out.println(loader.getClass().getName());
            loader = loader.getParent();
        }
        System.out.println(loader);

        String s = new ClassLoaderAttachment().toString();
        System.out.println(s);

        // 使用自定义类加载器
        Class<?> lib = new MyClassLoaderDecoder("lib").loadClass("top.chsi.ClassLoaderAttachment");
        Date d1 = (Date)lib.newInstance();
        System.out.println(d1);
    }
}
```

#### 自定义加密类加载器

```java
public class ClassLoaderAttachment extends Date {

    @Override
    public String toString() {
        return "hello world";
    }
}
public class MyClassLoader extends ClassLoader {

    @Override
    protected Class<?> findClass(String name) throws ClassNotFoundException {
        return super.findClass(name);
    }

    public static void cypher(InputStream is, OutputStream os) throws Exception{

        // 下面这段代码可能遇到255的字节，当成byte就变成了-1
//        byte b = 0;
//        while ((b = (byte)is.read()) != -1){
//            os.write(b^0xff);
//        }

        int b;
        while ((b = (byte)is.read()) != -1){
            os.write(((byte)b)^0xff);
        }
    }

    /**
     * 有包名的类不能调用无包名的类
     * @param args
     * @throws Exception
     */
    public static void main(String[] args) throws Exception {
        String srcpath = "C:\\Users\\admin\\IdeaProjects\\init\\src\\main\\java\\top.chsi.ClassLoaderAttachment.class";
        String destDir = "lib";
        FileInputStream fis = new FileInputStream(srcpath);
        String destFileName = srcpath.substring(srcpath.lastIndexOf("/")+1);
        String destpath = destDir + "\\" + destFileName;
        FileOutputStream fos = new FileOutputStream(destpath);
        cypher(fis, fos);
        fis.close();
        fos.close();
    }
}
```

#### 自定义解密类加载器

```java
public class MyClassLoaderDecoder extends ClassLoader {


    private String classpath;

    public static void cypher(InputStream is, OutputStream os) throws Exception{

        int b;
        while ((b = (byte)is.read()) != -1){
            os.write(((byte)b)^0xff);
        }
    }

    @Override
    protected Class<?> findClass(String name) throws ClassNotFoundException {
        String classFileName = classpath + "\\" + name.substring(name.lastIndexOf(".")) + ".class";
        FileInputStream fis = null;
        try {
            fis = new FileInputStream(classFileName);
            ByteArrayOutputStream bos = new ByteArrayOutputStream();
            cypher(fis, bos);
            System.out.println("aaa");
            byte[] bytes = bos.toByteArray();
            return defineClass(bytes, 0, bytes.length);
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            if (fis != null){
                try {
                    fis.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }

        return super.findClass(name);
    }


    public MyClassLoaderDecoder(){}
    public MyClassLoaderDecoder(String classpath){
        this.classpath = classpath;
    }

    public static void main(String[] args) throws Exception {
        // 使用自定义类加载器
        Class<?> lib = new MyClassLoaderDecoder("lib").loadClass("top.chsi.ClassLoaderAttachment");
        Date d1 = (Date)lib.newInstance();
        System.out.println(d1);
    }
}
```

#### 一个类加载器的高级问题的分析

- 编写一个能打印出自己的类加载器名称和当前类加载器的父子结构关系链的MyServlet，正常发布后，看到打印结果为WebAppClassloader.

- 把MyServlet.class文件打jar包，放到ext目录中，重启Tomcat，发现找不到HttpServlet.class的错误

- 把servlet.jar也放到ext目录下，问题解决了，打印结果是ExtclassLoader.

- 父级类加载器加载的类无法引用只能被子级类加载器加载的类，原理如下图：

image:../images/Sevlet加载原理图.png[]

```java
/**
  将该项目打成war包，放到Tomcat中，访问servlet的路径
 */
public class MyServlet extends HttpServlet {
    public void doGet(){
        response.setContenType("text/html");
        PrintWriter out = response.getWriter();
//        out 类似于System.out.print
        ClassLoader loader = this.getClass().getClassLoader();
        while (loader != null){
            out.println(loader.getClass().getName());
            loader = loader.getParent();
        }
        out.close();
    }
}
```


=== 性能监控工具

=== Java堆分析

=== 锁

=== Class文件结构

=== 字节码执行
