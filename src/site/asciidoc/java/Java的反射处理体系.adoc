=== 反射

反射的基石---->Class类

Class ---->代表一类事物

Java程序中的各个Java类属于同一类事物，描述这类事物的Java类名就是Class。

Class描述的就是Java class这一类事物。

Class类代表Java类，他的实例代表各个类在内存中的字节码。

一个类加载器加载到内存中，占用一片存储空间，这个空间里面的内容弄个就是类的字节码，不同的类的字节码是不同的，所以他们在内存中的内容是不同的，这一个个的空间可分别用一个个的对象来表示，这些对象显然具有相同的类型，这个类型就是Class类型。

得到字节码对应的实力对象的三种方法

* 类名.class
* 对象.getClass()
* Class.forName("类名")

九个预定义Class实例对象

八个基本数据类型和一个void, 参看Class.isPromitive()[是否是原始类型]方法的帮助，int.class == Integer.TYPE

void int float long double boolean char byte short

```java
    String str1 = "abc";
    Class cls1 = str1.getClass();
    Class cls2 = String.class;
    Class cls3 = Class.forName("java.lang.String");
    System.out.println(cls1 == cls2);  // ture
    System.out.println(cls1 == cls3);  // ture
 	System.out.println(cls1.isPrimitive());  //false
    System.out.println(Integer.class.isPrimitive());  //false
    System.out.println(int.class.isPrimitive());  //true
    System.out.println(int.class == Integer.class);  //false  不是同一份字节码
    System.out.println(int.class == Integer.TYPE); //true    TYPE常量表示的是包装类型包装的基本类型的字节码
    System.out.println(int[].class.isPrimitive());  //false  不是原始类型，是数组类型
    System.out.println(int[].class.isArray());  //true  判断该类型是不是数组
```

以上三种方式指向的是同一份字节码。

只要是在源程序中出现的类型，都有各自的Class实例对象。

#### 反射定义

反射就是把Java类中的各种成分映射成相应的java类。

一个类中的组成部分:成员变量、方法、构造方法、包等等信息也用一个个的Java类来表示。表示java类的Class类显然要提供一系列的方法来获得其中的变量，方法、构造方法、修饰符、包等信息，这些信息就是用相应类的实例对象来表示，他们是Field、Method、Constructor、Package等等。

一个类中的每个成员都可以用相应的反射API类的一个实例对象来表示。

一个类中的每一个成员都可以用相应的反射api类的一个实例对象来表示，通过调用Class类的方法可以得到这些实例对象后，得到这些实例对象后。

#### Constructor类

* Constructor类代表某个类中的一个构造方法
* 得到某个类所有的构造方法
* Constructor constrctors = Class.forName("java.lang.String").getConstructors();
* 得到某一个构造方法
* Constructor constrctor = Class.forName("java.lang.String").getConstructor(StringBuffer.class);
* 创建实例对象
* 通常方式：通常方式：String str = new String(new StringBuffer("abc"));
* 反射方式：String str = (String)constructor.newInstance(new StringBuffer("abc"))

```java
 Constructor<String> constructor = String.class.getConstructor(StringBuffer.class); //StringBuffer类型
 String abc = constructor.newInstance(new StringBuffer("abc"));  //StringBuffer对象
 System.out.println(abc.charAt(2));
```

调用获得的方法时，要用到上面相同类型的实例对象

##### Class.newInstance()方法

* String str = (String)Class.forName("java.lang.String").newInstance()
* 该方法内部先得到默认的构造方法，然后用该构造方法创建实例对象
* 该方法内部的具体代码是怎样写的呢？用到了缓存机制来保存默认构造方法的实例对象

#### Field类

Field类代表某个类中的一个成员变量

得到的Field对象是对应到类上面的成员变量

```java
public class ReflectPoint {

    private int x;
    public int y;

    public ReflectPoint(int x, int y) {
        this.x = x;
        this.y = y;
    }
}

ReflectPoint pt1 = new ReflectPoint(3, 5);
Field fieldY = pt1.getClass().getField("y");
// fieldY 只代表pt1对象的y变量，不代表人一个对象的值
// 取值时需要使用相应的对象
Object o = fieldY.get(pt1);
System.out.println(o);
// 对于私有变量我们使用getDeclaredField可以获取到。
Field fieldX = pt1.getClass().getDeclaredField("x");
// 虽然获取到了变量，但是还是获取不到值，需要设置可以访问
fieldX.setAccessible(true);  //暴力反射
Object x = fieldX.get(pt1);
System.out.println(x);

```

* 将任意一个对象中的所有String类型的成员变量所对应的字符串内容中的b改为a。

```java
 public static void main(String[] args) throws Exception {
        ReflectPoint pt1 = new ReflectPoint(3, 5);
        Field[] fields = pt1.getClass().getFields();
        for (Field field: fields){
            if(field.getType() == String.class){
                String o1 = (String)field.get(pt1);
                String s = o1.replace("b", "a");
                field.set(pt1,s);
            }
        }
        System.out.println(pt1);
    }
```

== 表示的是是不是一份

equals 表示的是是不是相同



#### Method类

* Method类代表类各类中的一个成员方法
* 得到类中的某一个方法
* Method charAt = Class.forName("java.lang.String").getMethod("charAt", int.class);
* 调用方法
* 通常方式：System.out.println(str.charAt(1));
* 反射方式:System.out.println(charAt.invoke(str,1));
* 如果传递给Method对象的invoke()方法的一个参数为null，说明该Method对象对应的是一个静态方法！

```java
Method charAt = Class.forName("java.lang.String").getMethod("charAt", int.class);
        Method valueOf = Class.forName("java.lang.String").getMethod("valueOf", int.class);
        Object a = charAt.invoke("abc", 2);
        // 静态方法的调用，第一个参数穿null
//        Object b = charAt.invoke(null, 2);
        String s = (String)valueOf.invoke("abc", 1);
        System.out.println(s);
        System.out.println(a);
```



* java1.4和java1.5的invoke方法的区别

  只是参数类型由Object[]变成了不定长参数

#### 用反射方式执行某个类中的main方法

* 目标

写一个程序，这个程序能够根据用户提供的类名，去执行该类中的main方法？

* 问题

启动java程序的main方法的参数是一个字符串数组，

* 解决办法

```java
public class App {

    public static void main( String[] args ) throws Exception {

        // 正常的调用方式
        TestArgument.main(new String[]{"111","222","333"});

        String className = args[0];
        // 反射方式的调用
        Method main = Class.forName(className).getMethod("main", String[].class);
        // 此处需要对数组进行强制转换成Object对象或者在进行一层数组包装，如果不转换将会报错，因为java会进行拆包。为了兼容j'd'k1.4的语法。
        main.invoke(null, (Object)new String[]{"111","222","333"});
        main.invoke(null, new Object[]{new String[]{"111","222","333"}});
    }
}

class TestArgument{
    public static void main(String[] args) {
        for (String arg: args){
            System.out.println(arg);
        }
    }
}
```

#### 数组的反射

* 具有相同维数和元素类型的数组属于同一个类型，即具有相同的Class实例对象
* 代表数组的Class实例对象的getSuperClass()方法返回的父类为Object类对应的Class
* 基本类型的以为数组可以被当作Object类型是用，不能当作Object[]类型使用，非基本类型的一维数组，既可以当作Object类型使用，又可以当作Object[]类型使用
* Arrays.asList()方法处理int[]和String[]是的差异
* Array工具类用于完成对数组的反射操作
* 思考题：怎么样得到数组中的元素类型？
* 无法得到数组中元素的类型，因为Object类型的数组中乐意放任意类型的数据
* 我们可以得到每一个具体元素的类型a4[0].getClass().getName()
* 基本数据类型是无法使用反射获取类型的

```java

```

```java
public class App {

    public static void main( String[] args ) throws Exception {

        int[] a1 = new int[]{1,2,3};
        int[] a2 = new int[4];
        int[][] a3 = new int[2][3];
        String[] a4 = new String[]{"a","b","c","d"};
        System.out.println(a4[0].getClass().getName());
        printObj(a1);
        printObj(a4);

    }

    public static void printObj(Object obj){
        Class<?> clazz = obj.getClass();
        System.out.println(obj.getClass().getTypeName());
        if (clazz.isArray()){
            int length = Array.getLength(obj);
            for (int i = 0; i < length; i++) {
                System.out.println(Array.get(obj,i));
            }
        }else {
            System.out.println(obj);
        }
    }
}
```

#### 反射的综合案例

```java
  public static void main( String[] args ) throws Exception {

//        Collection<ReflectPoint> collections = new ArrayList<>();
        Collection<ReflectPoint> collections = new HashSet<>();
        ReflectPoint pt1 = new ReflectPoint(3, 5);
        ReflectPoint pt2 = new ReflectPoint(5, 5);
        ReflectPoint pt3 = new ReflectPoint(3, 5);
        collections.add(pt1);
        collections.add(pt2);
        collections.add(pt3);
        collections.add(pt1);
        System.out.println(collections.size());

        // ArrayList是一种由顺序的集合，只是放对象的引用。
        // HashSet放数据时，先判断有没有对象，如果有了就不放
        // 当重写equals和hashcode方法时，就会根据具体的重写方式进行判断
        // 重写hashcode方法只有在使用hash算法的集合中才有意义。
        // 注意： 当一个对象被存储进HashSet集合中以后，就不能修改这个对象中的那些参与计算hash值的字段了
        //       否则，对象修改后的hash值与最初存储进HashSet集合中时的Hash值就不一样了，
        //       在这种情况下，即使在contaims方法使用该对象的当前引用作为的参数去HashSet
        //       集合中计算对象，也将返回找不到对象的结果，这样也会导致无法从HashSet集合中单独删除当前对象，从而造成内存泄漏

        pt1.y = 7;
        boolean remove = collections.remove(pt1);
        System.out.println(remove);
        System.out.println(collections.size());

    }
```

#### 反射的作用-->实现框架功能

* 框架与框架要解决的核心问题
* 我做房子卖给用户住，有用户自己安装门窗和空调，我做的房子就是框架，用户需要使用我的框架吧门窗插入进我提供的框架中，框架与工具类有区别，工具类备用胡的类调用，而框架则是调用用户提供的类
* 框架要解决的核心问题
* 我在写框架（房子）时，你这个用户可能还在上小学，还不会写程序呢？我写的框架怎样能调用到你以后的得嘞（门窗）呢？
* 因为在写程序时无法知道要被调用的类名，所以，载程序中无法直接new某个类的实例对象了。而需要用反射方式来做。
* 综合案例
* 先直接用new语句创建ArrayKist和HashSet的实例对象，比较两个集合的运行结果差异。
* 然后改为采用配置文件加反射的方式创建ArrayList和HashSet的对象，比较观察运行结果差异

#### 用类加载器的方式管理资源和配置文件

配置文件一定要用完整的路径，但完整的路径不是硬编码，而是运算出来的。

```java
  public static void main( String[] args ) throws Exception {
        // 类加载器可以将.class文件加载到内存中，也就一定可以将普通文件加载到内存中
        // 类加载器会在所有的classPath指定的路径查找
        // 编译器会将源程序的目录下的所有java文件编译成.class并将非java文件原封不动的复制过去
        final InputStream resourceAsStream = App.class.getClassLoader().getResourceAsStream("haiyang/yu/config.properties");
        Properties properties = new Properties();
        properties.load(resourceAsStream);
        System.out.println(properties);

        // 还可以使用FileInputStream()进行对配置文件的加载
//        InputStream stream = new FileInputStream("config.propertices");

        // 这种方式是相对于类加载所在的路径的相对路径，也可以使用绝对路径，绝对路径时从完整的包开始的
        InputStream resourceAsStream1 = App.class.getResourceAsStream("config.properties");
    }
```

