=== Java5 之前
并发实现

- Java Green Thread
- Java Native Thread

编程模型

- Thread
- Runnable

实现的局限性

- 缺少线程管理的原生支持
- 缺少执行完成的原生支持
- 执行结果获取困难
- 缺少锁API
- Double Check Locking 不确定性

=== Java5

并发实现
- JUC = java.util.concurrent

编程模型

- Executor
- Runnable\Callable
- Future

=== Java6

=== Java7

并行框架

- Fork/Join

编程模型

- ForkJoinPool
- ForkJoinTask
- RecursiveAction

Future的限制

- 无法手动完成
- 阻塞式结果返回
- 无法链式多个Future
- 无法合并多个Future结果
- 缺少异常处理

=== Java8

异步并行框架

- Fork/Join

编程模型

- CompletionStage
- CompletableFuture

=== Java9




### 多线程

- 程序、进程、线程的概念
- **Java中多线程的创建和使用**
- 继承Thread类与实现Runnable接口
- Thread类的主要方法
- 线程的调度与设置优先级
- 线程的生命周期
- **线程的同步**
- 线程的通信

1. 基本概念：程序、进程、线程
- 程序（program）是为完成特定任务、用某种语言编写的一组指令的集合。即指一段静态代码，静态对象。
- 进程（process）是程序的一次执行过程，或是正在运行的一个程序。动态过程：有它自身的产生、存在和消亡的过程。
- 如：运行中的QQ，运行中的MP3播放器
- 程序是静态的，进程是动态的
- 线程（Thread）进程可进一步细化为线程，是一个程序内部的一条执行路径。
- 若一个程序可同一时间执行多个线程，就是支持多线程的
2. 何时需要多线程
- 程序需要同时执行两个或多个任务
- 程序需要实现一些需要等待的任务时，如用户输入、文件读写操作、网络操作、搜索等。
- 需要一些后台运行的程序时。
3. 多线程的创建和启动
- Java语言的JVM允许程序运行多个线程，他通过java.lang.Thread类来实现。
- Thread类的特性
- 每个线程都是通过某个特定Thread对象的run()方法来完成操作的，经常把run()方法的主体称为线程体
- 通过该Thread对象的start()方法来调用这个线程

```java
package top.chsi.thread;

/**
 * 创建一个子线程，打印数字，主线程执行同样的操作
 * 创建多线程的第一种方式：继承java.lang.Thread类
 * 1. 创建一个继承于Thread类的子类
 */
class SubThread extends Thread {
    // 2. 重写Thread类的run方法, 方法内实现此自行承要完成的功能
    @Override
    public void run() {
        for (int i = 0; i < 100; i++) {
            // 子类重写的方法不能抛出比父类方法抛出的更大范围的异常
//            try {
//                Thread.currentThread().sleep(1000);
//            } catch (InterruptedException e) {
//                e.printStackTrace();
//            }
            System.out.println(i + Thread.currentThread().getName() + Thread.currentThread().getPriority());
        }
    }
}
public class TestThread {
    public static void main(String[] args) throws InterruptedException {
        // 3. 创建一个子类的对象
        SubThread subThread = new SubThread();
        subThread.setPriority(Thread.MAX_PRIORITY);
        // 4. 调用线程的start(),启动子线程，调用相应的run()
        // 一个线程只能执行一次start()
        // 不能通过Thread对象的run()去启动一个线程
        subThread.start();

        /* 线程中常用方法：
            1. start()启动线程并执行相应的run方法
            2. run()子线程要执行的代码放入run方法中
            3. currentThread()静态方法，调取当前的线程
            4. getName()获取此线程的名字
            5. setName()设置此线程的名字
            6. yield()调用此方法的线程释放当前CPU执行权，释放后也有可能还抢回来
            7. join()在A线程中调用B线程的join（）方法，表示当执行到此方法，A停止执行，直至B线程执行完，在执行A线程
            8. isAlive():判断当前线程是否还存活
            9. sleep()显式的让当前线程睡眠参数的毫秒数
            10. 线程通信：wait() notify() notifyAll()
            11. 设置线程的优先级
                getPriority()  setPriority(int newPriority):改变线程的优先级
         */
        for (int i = 0; i < 100; i++) {
//            if (i%10 == 0) {
//                Thread.currentThread().yield();
//            }
//            if (i ==20){
//                subThread.join();
//            }
            System.out.println(i + Thread.currentThread().getName() + Thread.currentThread().getPriority());
        }
    }
}
```

```java
package top.chsi.thread;


/**
 *
 * 对比继承的方式和实现的方式
 * 1. 联系：Thread实现了Runnable方法
 * 2. 哪个方式好？实现的方式优于继承的方式
 *         避免java单继承的局限性
 *         如果多个线程要操作同一份资源，更适合使用实现的方式。
 * 创建多线程方式二：实现Runnable接口方式
 * 1. 创建一个实现了Runnable接口的类
 */
class PrintNum1 implements Runnable {

    // 实现抽象方法
    @Override
    public void run() {
        for (int i = 0; i < 100; i++) {
            System.out.println(i + Thread.currentThread().getName() + Thread.currentThread().getPriority());
        }
    }
}
public class TestThread1 {
    public static void main(String[] args) {
        // 3. 创建一个Runnable接口实现类的对象
        PrintNum1 printNum1 = new PrintNum1();
        // 要想启动一个多线程必须调用start()方法
        // 启动线程，执行Thread对象生成时构造器形参的对象的run()方法
        // 4. 将此对象作为形参传递给Thread类的构造器中，创建Thread类的对象，此对象即为一个线程
        // 5. 启动线程：执行Thread对象生成时构造器形参的对象的run方法
        new Thread(printNum1).start();
    }
}

```

```java
package top.chsi.thread;

/**
 * 模拟火车站售票窗口，开启三个窗口售票，总票数为100张
 */

class Window extends Thread {
    // 每个对象都有100张
//    int ticket = 100;
    // 类变量可以解决上面的问题，所有对象公用变量，生命周期太长
    static int ticket = 100;

    public Window(String name){
        super(name);
    }
    @Override
    public void run() {
        while (true){
            if (ticket > 0){
                System.out.println(Thread.currentThread().getName() + "售票:" + ticket--);
            }else {
                break;
            }
        }
    }
}
/**
 * 使用实现Runnable接口的方式，售票
 */
class Window1 implements Runnable {
    int ticket = 100;
    @Override
    public void run() {
        while (true){
            if (ticket > 0){
                // 此时代码还存在一定的问题，加上以下一行代码可以放大这个错误
                // 因此，此程序存在线程的安全问题，打印车票是，会出现重票、错票的问题
                try {
                    Thread.currentThread().sleep(10);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println(Thread.currentThread().getName() + "售票:" + ticket--);
            }else {
                break;
            }
        }
    }
}

/**
 * 使用实现Runnable接口的方式，售票
 * 解决线程安全的问题
 * 1. 线程安全问题存在的原因
 *      由于一个线程在操作共享数据过程中未执行完的情况下，另外的线程参与进来，导致共享数据存在安全问题。
 * 2. 如何来解决线程的安全问题？
 *      必须让一个线程操作共享数据完毕以后，其他线程才有机会参与贡献数据的操作
 * 3. Java如何实现线程的安全：线程的同步机制
 *      方式1：
 *          同步代码块
 *      方式2：
 *          同步方法
 *      方法3：
 *          锁的方式
 */
class Window2 implements Runnable {
    int ticket = 100;
    Object o = new Object();
    @Override
    public void run() {
        while (true){

            // 1. 问题代码
//            if (ticket > 0){
//                try {
//                    Thread.currentThread().sleep(10);
//                } catch (Exception e) {
//                    e.printStackTrace();
//                }
//                System.out.println(Thread.currentThread().getName() + "售票:" + ticket--);
//            }else {
//                break;
//            }

            // 2. 同步代码块（操作共享数据的代码）
            //    1.共享数据：多个线程共同操作的同一个数据（变量）
            //    2. 同步监视器：由任何一个类的对象来冲当。哪个线程获取此监视器，谁就执行大括号里的代码，俗称锁
            //        要求所有的线程必须使用同一把锁, 可以创建任意一个对象，一般情况下使用this，this表示当前对象
            //        如果使用继承Thread的方式实现，使用this就会出错，因为所使用的线程对象不是一个
//            synchronized (o){
//                if (ticket > 0){
//                    try {
//                        Thread.currentThread().sleep(10);
//                    } catch (Exception e) {
//                        e.printStackTrace();
//                    }
//                    System.out.println(Thread.currentThread().getName() + "售票:" + ticket--);
//                }else {
//                    break;
//                }
//            }

            // 3. 同步方法
            show();

        }
    }

    /**
     * 将操作共享数据的方法声明为synchronized。即此方法为同步方法，
     * 能够保证当其中一个线程执行此方法时其他线程在外等待，直至此线程执行完此方法。
     * 同步方法也有锁，同步方法的锁为当前对象
     * 继承Thread的方式是不能使用同步方法的
     */
    private synchronized void show(){
            if (ticket > 0){
                try {
                    Thread.sleep(10);
                } catch (Exception e) {
                    e.printStackTrace();
                }
                System.out.println(Thread.currentThread().getName() + "售票: " + ticket--);
            }
    }
}
public class TestWindow {
    public static void main(String[] args) {
//        Window w1 = new Window("窗口1");
//        Window w2 = new Window("窗口2");
//        Window w3 = new Window("窗口3");
//        w1.start();
//        w2.start();
//        w3.start();
//        Window1 w = new Window1();
        Window2 w = new Window2();
        Thread t1 = new Thread(w);
        Thread t2 = new Thread(w);
        Thread t3 = new Thread(w);
        t1.start();
        t2.start();
        t3.start();
    }
}
```

**使用多线程的优点**
背景：只使用单个线程完成多个任务（调用多个方法），肯定比用多个线程来完成用的时间更短，为何仍需多线程呢？
多线程程序的优点：

- 提高应用程序的响应 对图形化界面更有意义，可增强用户体验。
- 提高计算机系统CPU的利用率
- 改善程序结构。将既长优复杂的进程分为多个线程独立运行，利于理解和修改
**补充：线程的分类**
Java中的线程分为两类：一种是守护线程，一种是用户线程
- 他们在几乎每个方面都是相同的，唯一的区别就是判断JVM何时离开
- 守护线程是用来服务用户线程的，通过在start方法前调用thread.setDaemon(true)可以吧一个用户线程变成一个守护线程
- java垃圾回收就是一个典型的守护线程
- 若jvm中都是守护线程，当前JVM将退出
**线程的生命周期**
image:../images/生命周期.png[]
image:../images/1536330739_32693.png[]

**程序运行出没出错，与你程序有没有错误是两码事**
image:../images/1536331545_21239.png[]
image:../images/1536331966_21997.png[]
image:../images/1536334248_26825.png[]

image:../images/1536334270_26413.png[]
**线程的同步的弊端：由于同一个时间只能有一个线程访问共享数据，效率变低了。**
image:../images/1536335206_26759.png[]
image:../images/1536454890_15895.png[]
suspend已经过时，可能导致线程死锁。

image:../images/1536336191_7890.png[]

image:../images/1536336211_27635.png[]
死锁是我们在使用同步时要避免的问题。

image:../images/死锁_1536412865_15313.png[]
image:../images/b_1536412887_10533.png[]
image:../images/a_1536412905_592.png[]

```java
package top.chsi.thread;

/**
 * 思索问题：处理线程同步是容易出现
 * 写代码时避免死锁
 */
public class DeadLock {

    private final static StringBuffer sb1 = new StringBuffer();
    private final static StringBuffer sb2 = new StringBuffer();

    public static void main(String[] args) {
        new Thread(){
            @Override
            public void run() {
                synchronized (sb1){
                    try {
                        Thread.sleep(10);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    sb1.append("A");
                    synchronized (sb2){
                        sb2.append("B");
                        System.out.println(sb1);
                        System.out.println(sb2);
                    }
                }
            }
        }.start();
        new Thread(){
            @Override
            public void run() {
                synchronized (sb2){
                    try {
                        Thread.sleep(10);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    sb2.append("C");
                    synchronized (sb1){
                        sb1.append("D");
                        System.out.println(sb1);
                        System.out.println(sb2);
                    }
                }
            }
        }.start();
    }
}
```

image:../images/1536413089_11144.png[]


```java
package top.chsi.thread;

/**
 * 线程通信
 * 使用两个线程打印1-100，线程1和线程2交替打印
 * 使用wait notify notifyall 都得在同步代码块或同步方法中
 * wait: 一旦一个线程执行到wait，就释放当前的锁
 * notify notifyall 唤醒wait的一个或所有线程
 */

class PrintNum implements Runnable {

    int num = 1;
    @Override
    public void run() {
        while (true){
            synchronized (this) {
                notify();
                if (num <= 100) {
                    try {
                        Thread.sleep(10);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    System.out.println(Thread.currentThread().getName() + ": " + num);
                    num++;
                } else {
                    break;
                }
                try {
                    wait();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}
public class ThreadCommunication {
    public static void main(String[] args) {
        PrintNum p = new PrintNum();
        Thread t1 = new Thread(p);
        Thread t2 = new Thread(p);
        t1.start();
        t2.start();
    }
}
```

生产者和消费者

```java
package top.chsi.thread;

/**
 * 生产者消费者的问题
 */

class Clerk {
    int product;
    public synchronized void addProduct(){
        if (product >= 20){
            try {
                wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }else {
            product++;
            System.out.println(Thread.currentThread().getName() + ":生产了 " + product);
            notify();
        }
    }

    public synchronized void consumeProduct(){
        if (product <= 0){
            try {
                wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }else {
            System.out.println(Thread.currentThread().getName() + ":消费了 " + product);
            product--;
            notify();
        }
    }
}

class Producer implements Runnable{

    Clerk clerk;
    public Producer(Clerk clerk){
        this.clerk = clerk;
    }
    @Override
    public void run() {
        System.out.println("生产者开始生产产品");
        while (true) {
            try {
                Thread.sleep(100);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            clerk.addProduct();
        }
    }
}

class Consume implements Runnable{
    Clerk clerk;
    public Consume (Clerk clerk){
        this.clerk = clerk;
    }
    @Override
    public void run() {
        System.out.println("消费者开始消费");
        while (true){
            try {
                Thread.sleep(100);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            clerk.consumeProduct();
        }
    }
}
public class TestProduceConsume {
    public static void main(String[] args) {
        Clerk clerk = new Clerk();
        Producer producer = new Producer(clerk);
        Producer producer1 = new Producer(clerk);
        Consume consume = new Consume(clerk);
        new Thread(producer).start();
        new Thread(producer1).start();
        new Thread(consume).start();
    }
}
```


4. 线程的调度
- 调度策略
- 时间片
- 抢占式：高优先级的线程抢占CPU
- Java的调度方法
- 同优先级线程组成先进先出队列（先到先服务），使用时间片策略
- 对高优先级，使用优先调度的抢占式策略
5. 线程的优先级



多线程
- 进程
- 线程
- 多线程存在的意义
- 线程的创建方式
- 多线程的特性

